---
title: 48-redis的LRU缓存清除算法讲解以及相关配置使用
date: 2018-12-25 13:40:29
tags:
categories: redis
---


如果不断地将数据写入```redis```，然而```redis```的内存是有限的，每个```redis```实例最大一般也就是设置给```10G```。

那如果不断地写入数据，当数据写入的量超过了```redis```能承受的范围之后，该怎么玩儿呢？？？

```redis```是会在数据量超过一个最大的限度之后，就会将数据进行清理，从内存中清理掉一些数据。

只有清理掉一些数据之后，才能将新的数据写入内存中。

## LRU算法概述

```redis```默认情况下使用LRU策略的，因为内存是有限的，但是如果不断地往```redis```里面写入数据，那肯定是没法将所有的数据存放在内存的。

所以```redis```默认情况下，当内存中写入的数据很满之后，就会使用```LRU```算法清理掉内存部分中的数据，腾出一些空间来，然后让新的数据写入```redis```缓存中。

```LRU：Least Recently Used```：最近最少使用算法

将最近一段时间内，最少使用的一些数据，给干掉。比如说有一个key，在最近1个小时内，只被访问了一次; 还有一个key在最近1个小时内，被访问了1万次。

这个时候比如你要将部分数据给清理掉，你会选择清理哪些数据啊？肯定是那个在最近小时内被访问了1万次的数据。

## 缓存清理设置

```redis.conf```配置文件设置。

```maxmemory```：设置```redis```用来存放数据的最大的内存大小，一旦超出这个内存大小之后，就会立即使用LRU算法清理掉部分数据。

如果用```LRU```，那么就是将最近最少使用的数据从缓存中清除出去。

对于64 bit的机器，如果```maxmemory```设置为0，那么就默认不限制内存的使用，直到耗尽机器中所有的内存为止; 但是对于32 bit的机器，有一个隐式的闲置就是3GB。

```maxmemory-policy```，可以设置内存达到最大闲置后，采取什么策略来处理。

>1. ```noeviction```: 如果内存使用达到了```maxmemory```，```client```还要继续写入数据，那么就直接报错给客户端；
>1. allkeys-lru: 就是我们常说的LRU算法，移除掉最近最少使用的那些keys对应的数据；
>1. volatile-lru: 也是采取LRU算法，但是仅仅针对那些设置了指定存活时间（TTL）的key才会清理掉；
>1. allkeys-random: 随机选择一些key来删除掉；
>1. volatile-random: 随机选择一些设置了TTL的key来删除掉；
>1. volatile-ttl: 移除掉部分keys，选择那些TTL时间比较短的keys；

在```redis```里面，写入```key-value```对的时候，是可以设置TTL，存活时间，比如你设置了60s，那么一个key-value对，在60s之后就会自动被删除。

redis的使用，各种数据结构，list，set，等等


redis，给了这么多种乱七八糟的缓存清理的算法，其实真正常用的可能也就那么一两种，allkeys-lru是最常用的。

## 缓存清理的流程

>1. 客户端执行数据写入操作；
>1. redis server接收到写入操作之后，检查maxmemory的限制，如果超过了限制，那么就根据对应的policy清理掉部分数据；
>1. 写入操作完成执行；

## redis的LRU近似算法

科普一个相对来说稍微高级一丢丢的知识点。

redis采取的是LRU近似算法，也就是对keys进行采样，然后在采样结果中进行数据清理

redis 3.0开始，在LRU近似算法中引入了pool机制，表现可以跟真正的LRU算法相当，但是还是有所差距的，不过这样可以减少内存的消耗

redis LRU算法，是采样之后再做LRU清理的，跟真正的、传统、全量的LRU算法是不太一样的

maxmemory-samples，比如5，可以设置采样的大小，如果设置为10，那么效果会更好，不过也会耗费更多的CPU资源

